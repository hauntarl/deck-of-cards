package deck

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
)

// ExampleCard tests the output generated by
//  go:generate stringer -type=Suit,Rank -output card_string.go
// for type Suit and Rank, combined by implementing Stringer for Card type.
func ExampleCard() {
	fmt.Println(Card{Rank: Ace, Suit: Heart})
	fmt.Println(Card{Rank: Two, Suit: Spade})
	fmt.Println(Card{Rank: Nine, Suit: Club})
	fmt.Println(Card{Rank: Jack, Suit: Diamond})
	fmt.Println(Card{Suit: Joker})

	// Output:
	// Ace of Hearts
	// Two of Spades
	// Nine of Clubs
	// Jack of Diamonds
	// Joker
}

// TestNew validates the output from constructor of deck of cards.
func TestNew(t *testing.T) {
	cards := New()
	// 1. expected number of cards in a deck = 13 ranks * 4 suits
	if len(cards) != 13*4 {
		t.Fatalf("expected %d cards, got: %d", 13*4, len(cards))
	}
	// 2. first 13 cards are all of one suit
	fir := cards[0].Suit
	for i := 1; i < 13; i++ {
		if cards[i].Suit != fir {
			t.Fatal("first 13 cards of given deck do not belong to same suit.")
		}
	}
	// 3. next 13 are of different suit
	sec := cards[13].Suit
	for i := 14; i < 26; i++ {
		if cards[i].Suit != sec {
			t.Fatal("next 13 cards of given deck do not belong to same suit.")
		}
	}
	// 4. all the suits are present
	set := map[Suit]struct{}{}
	for i := 0; i < len(cards); i += 13 {
		set[cards[i].Suit] = struct{}{}
	}
	if len(set) != 4 {
		t.Fatalf("expected 4 suits, got: %d", len(set))
	}
}

// TestDefaultSort validates the output of constructor when passed DefaultSort
// as a functional option.
func TestDefaultSort(t *testing.T) {
	cards, want := New(DefaultSort), Card{Suit: Spade, Rank: Ace}
	if cards[0] != want {
		t.Fatalf("after default sort: expected '%v', got '%v'", want, cards[0])
	}
}

// TestSort validates the output generated using generic sorting option
func TestSort(t *testing.T) {
	want, got := New(DefaultSort), New(Sort(Less))
	if !reflect.DeepEqual(want, got) {
		t.Fatal("the generic sort function didn't return expected output")
	}

	rev := New(Sort(func(cards []Card) func(i, j int) bool {
		return func(i, j int) bool {
			return value(cards[i]) > value(cards[j])
		}
	}))
	card := Card{Suit: Heart, Rank: King}
	if rev[0] != card {
		t.Fatalf("after reverse sort: expected '%v', got '%v'", card, rev[0])
	}
}

// TestShuffle validates the shuffling by making the rand.Source deterministic.
func TestShuffle(t *testing.T) {
	src := rand.NewSource(0)
	// first call to r.Shuffle() with seed as 0 will produce following indices:
	// [19 36 ...]
	cards := New()
	fir, sec := cards[19], cards[36] // expected first and second elements
	cards = New(Shuffle(src))
	if cards[0] != fir || cards[1] != sec {
		t.Fatalf(
			"expected first='%v', second='%v', got first='%v', second='%v'",
			fir, sec, cards[0], cards[1],
		)
	}
}

// TestJoker validates whether given number of jokers were added in the deck.
func TestJoker(t *testing.T) {
	want := 3
	cards := New(Jokers(want))
	got := 0
	for _, card := range cards {
		if card.Suit == Joker {
			got++
		}
	}
	if got != want {
		t.Fatalf("total jokers: expected %d, got %d", want, got)
	}
}

// TestFilter validates whether cards matching predicates were removed.
func TestFilter(t *testing.T) {
	// 1. filter all the hearts
	cards := New(Filter(func(c Card) bool { return c.Suit == Heart }))
	want := 52 - 13
	if len(cards) != want {
		t.Fatalf("after filter: expected cards %d, got %d", want, len(cards))
	}
	for _, card := range cards {
		if card.Suit == Heart {
			t.Fatalf("after filter: expected 0 Hearts")
		}
	}
	// 2. filter all the 2s and 3s
	cards = New(Filter(func(c Card) bool {
		return c.Rank == Two || c.Rank == Three
	}))
	want = 52 - 8
	if len(cards) != want {
		t.Fatalf("after filter: expected cards %d, got %d", want, len(cards))
	}
	for _, card := range cards {
		if card.Rank == Two || card.Rank == Three {
			t.Fatalf("after filter: expected 0 Twos and 0 Threes")
		}
	}
}

// TestDeck validates whether multiple decks were created or not.
func TestDeck(t *testing.T) {
	cards, want := New(Decks(2)), 52*2
	if len(cards) != want {
		t.Fatalf("multiple decks: expected cards %d, got %d", want, len(cards))
	}
}
